import {
  require_gun
} from "./chunk-6CISWIPS.js";
import {
  __commonJS
} from "./chunk-PR4QN5HX.js";

// node_modules/gun/lib/axe.js
var require_axe = __commonJS({
  "node_modules/gun/lib/axe.js"() {
    var Gun = typeof window !== "undefined" ? window.Gun : require_gun();
    var u;
    Gun.on("opt", function(at) {
      start(at);
      this.to.next(at);
    });
    function start(root) {
      if (root.axe) {
        return;
      }
      var opt = root.opt, peers = opt.peers;
      if (false === opt.axe) {
        return;
      }
      if (typeof process !== "undefined" && "false" === "" + (process.env || "").AXE) {
        return;
      }
      Gun.log.once("AXE", "AXE relay enabled!");
      var axe = root.axe = {}, tmp, id;
      var mesh = opt.mesh = opt.mesh || Gun.Mesh(root);
      var dup = root.dup;
      mesh.way = function(msg) {
        if (!msg) {
          return;
        }
        if (msg.get) {
          return GET(msg);
        }
        if (msg.put) {
          return;
        }
        fall(msg);
      };
      function GET(msg) {
        if (!msg) {
          return;
        }
        var via = (msg._ || "").via, soul, has, tmp2, ref;
        if (!via || !via.id) {
          return fall(msg);
        }
        if (!(ref = REF(msg)._)) {
          return fall(msg);
        }
        ref.asked = +/* @__PURE__ */ new Date();
        GET.turn(msg, ref.route, 0);
      }
      GET.turn = function(msg, route, turn) {
        var tmp2 = msg["#"], tag = dup.s[tmp2], next;
        if (!tmp2 || !tag) {
          return;
        }
        clearTimeout(tag.lack);
        if (tag.ack && (tmp2 = tag["##"]) && msg["##"] === tmp2) {
          return;
        }
        next = Object.maps(route || opt.peers).slice(turn = turn || 0);
        if (!next.length) {
          if (!route) {
            return;
          }
          GET.turn(msg, u, 0);
          return;
        }
        setTimeout.each(next, function(id2) {
          var peer = opt.peers[id2];
          turn++;
          if (!peer || !peer.wire) {
            route && route.delete(id2);
            return;
          }
          if (mesh.say(msg, peer) === false) {
            return;
          }
          if (0 == turn % 3) {
            return 1;
          }
        }, function() {
          tag["##"] = msg["##"];
          tag.lack = setTimeout(function() {
            GET.turn(msg, route, turn);
          }, 25);
        }, 3);
      };
      function fall(msg) {
        mesh.say(msg, opt.peers);
      }
      function REF(msg) {
        var ref = "", soul, has, tmp2;
        if (!msg || !msg.get) {
          return ref;
        }
        if ("string" == typeof (soul = msg.get["#"])) {
          ref = root.$.get(soul);
        }
        if ("string" == typeof (tmp2 = msg.get["."])) {
          has = tmp2;
        } else {
          has = "";
        }
        var via = (msg._ || "").via, sub = via.sub || (via.sub = new Object.Map());
        (sub.get(soul) || sub.set(soul, tmp2 = new Object.Map()) && tmp2).set(has, 1);
        via.id && ref._ && (ref._.route || (ref._.route = new Object.Map())).set(via.id, via);
        return ref;
      }
      function LEX(lex) {
        return (lex = lex || "")["="] || lex["*"] || lex[">"] || lex;
      }
      root.on("in", function(msg) {
        var to = this.to, tmp2;
        if ((tmp2 = msg["@"]) && (tmp2 = dup.s[tmp2])) {
          tmp2.ack = (tmp2.ack || 0) + 1;
          if (tmp2.it && tmp2.it.get && msg.put) {
            var get = tmp2.it.get || "", ref = REF(tmp2.it)._, via = (tmp2.it._ || "").via || "", sub;
            if (via && ref) {
              via.id && (ref.route || (ref.route = new Object.Map())).set(via.id, via);
              sub = via.sub || (via.sub = new Object.Map());
              ref && (sub.get(LEX(get["#"])) || sub.set(LEX(get["#"]), sub = new Object.Map()) && sub).set(LEX(get["."]), 1);
              via = (msg._ || "").via || "";
              if (via) {
                via.id && (ref.route || (ref.route = new Object.Map())).set(via.id, via);
                sub = via.sub || (via.sub = new Object.Map());
                if (ref) {
                  var soul = LEX(get["#"]), sift = sub.get(soul), has = LEX(get["."]);
                  if (has) {
                    (sift || sub.set(soul, sift = new Object.Map()) && sift).set(has, 1);
                  } else if (!sift) {
                    sub.set(soul, sift = new Object.Map());
                    sift.set("", 1);
                  }
                }
              }
            }
          }
          if (tmp2 = tmp2.back) {
            setTimeout.each(Object.keys(tmp2), function(id2) {
              to.next({ "#": msg["#"], "@": id2, ok: msg.ok });
            });
            return;
          }
        }
        to.next(msg);
      });
      root.on("create", function(root2) {
        this.to.next(root2);
        var Q = {};
        root2.on("put", function(msg) {
          var eve = this, at = eve.as, put = msg.put, soul = put["#"], has = put["."], val = put[":"], state = put[">"], q, tmp2;
          eve.to.next(msg);
          if (msg["@"]) {
            return;
          }
          if (!soul || !has) {
            return;
          }
          var ref = root2.$.get(soul)._, route = (ref || "").route;
          if (!route) {
            return;
          }
          if (ref.skip && ref.skip.has == has) {
            ref.skip.now = msg["#"];
            return;
          }
          (ref.skip = { now: msg["#"], has }).to = setTimeout(function() {
            setTimeout.each(Object.maps(route), function(pid) {
              var peer, tmp3;
              var skip = ref.skip || "";
              ref.skip = null;
              if (!(peer = route.get(pid))) {
                return;
              }
              if (!peer.wire) {
                route.delete(pid);
                return;
              }
              var sub = (peer.sub || (peer.sub = new Object.Map())).get(soul);
              if (!sub) {
                return;
              }
              if (!sub.get(has) && !sub.get("")) {
                return;
              }
              var put2 = peer.put || (peer.put = {});
              var node = root2.graph[soul], tmp3;
              if (node && u !== (tmp3 = node[has])) {
                state = state_is(node, has);
                val = tmp3;
              }
              put2[soul] = state_ify(put2[soul], has, state, val, soul);
              tmp3 = dup.track(peer.next = peer.next || String.random(9));
              (tmp3.back || (tmp3.back = {}))["" + (skip.now || msg["#"])] = 1;
              if (peer.to) {
                return;
              }
              peer.to = setTimeout(function() {
                flush(peer);
              }, opt.gap);
            });
          }, 9);
        });
      });
      function flush(peer) {
        var msg = { "#": peer.next, put: peer.put, ok: { "@": 3, "/": mesh.near } };
        peer.next = peer.put = peer.to = null;
        mesh.say(msg, peer);
      }
      var state_ify = Gun.state.ify, state_is = Gun.state.is;
      function relayUp(msg) {
        mesh.say(msg, axe.up);
      }
      ;
      (function() {
        axe.up = {};
        var hi = mesh.hear["?"];
        mesh.hear["?"] = function(msg, peer) {
          var p;
          hi(msg, peer);
          if (!peer.pid) {
            return;
          }
          if (peer.pid === opt.pid) {
            mesh.bye(peer);
            return;
          }
          if (p = axe.up[peer.pid]) {
            if (p === peer) {
              return;
            }
            if (opt.pid > peer.pid) {
              p = peer;
              peer = axe.up[p.pid];
            }
            p.url = p.url || peer.url;
            mesh.bye(peer);
            axe.up[p.pid] = p;
            return;
          }
          if (!peer.url) {
            return;
          }
          axe.up[peer.pid] = peer;
          if (axe.stay) {
            axe.stay();
          }
        };
        mesh.hear["opt"] = function(msg, peer) {
          if (msg.ok) {
            return;
          }
          var tmp2 = msg.opt;
          if (!tmp2) {
            return;
          }
          tmp2 = tmp2.peers;
          if (!tmp2 || "string" != typeof tmp2) {
            return;
          }
          if (99 <= Object.keys(axe.up).length) {
            return;
          }
          mesh.hi({ id: tmp2, url: tmp2, retry: 9 });
          if (peer) {
            mesh.say({ dam: "opt", ok: 1, "@": msg["#"] }, peer);
          }
        };
        axe.stay = function() {
          clearTimeout(axe.stay.to);
          axe.stay.to = setTimeout(function(tmp2, urls) {
            if (!(tmp2 = root.stats && root.stats.stay)) {
              return;
            }
            urls = {};
            Object.keys(axe.up || "").forEach(function(p) {
              p = (axe.up || "")[p];
              if (p.url) {
                urls[p.url] = {};
              }
            });
            (tmp2.axe = tmp2.axe || {}).up = urls;
          }, 1e3 * 9);
        };
        setTimeout(function(tmp2) {
          if (!(tmp2 = root.stats && root.stats.stay && root.stats.stay.axe)) {
            return;
          }
          if (!(tmp2 = tmp2.up)) {
            return;
          }
          if (!(tmp2 instanceof Array)) {
            tmp2 = Object.keys(tmp2);
          }
          setTimeout.each(tmp2 || [], function(url) {
            mesh.hear.opt({ opt: { peers: url } });
          });
        }, 1e3);
      })();
      ;
      (function() {
        opt.mob = opt.mob || 9900;
        root.on("hi", function(peer) {
          this.to.next(peer);
          if (peer.url) {
            return;
          }
          var count = (
            /*Object.keys(opt.peers).length ||*/
            mesh.near
          );
          if (opt.mob >= count) {
            return;
          }
          var peers2 = {};
          Object.keys(axe.up).forEach(function(p) {
            p = axe.up[p];
            p.url && (peers2[p.url] = {});
          });
          mesh.say({ dam: "mob", mob: count, peers: peers2 }, peer);
          setTimeout(function() {
            mesh.bye(peer);
          }, 9);
        });
        root.on("bye", function(peer) {
          this.to.next(peer);
        });
      })();
    }
    (function() {
      var from = Array.from;
      Object.maps = function(o) {
        if (from && o instanceof Map) {
          return from(o.keys());
        }
        if (o instanceof Object.Map) {
          o = o.s;
        }
        return Object.keys(o);
      };
      if (from) {
        return Object.Map = Map;
      }
      (Object.Map = function() {
        this.s = {};
      }).prototype = { set: function(k, v) {
        this.s[k] = v;
        return this;
      }, get: function(k) {
        return this.s[k];
      }, delete: function(k) {
        delete this.s[k];
      } };
    })();
  }
});

// node_modules/gun/axe.js
var require_axe2 = __commonJS({
  "node_modules/gun/axe.js"(exports, module) {
    (function() {
      var sT = setTimeout || {}, u;
      if (typeof window !== "" + u) {
        sT.window = window;
      }
      var AXE = (sT.window || "").AXE || function() {
      };
      if (AXE.window = sT.window) {
        AXE.window.AXE = AXE;
      }
      var Gun = (AXE.window || "").GUN || require_gun();
      (Gun.AXE = AXE).GUN = AXE.Gun = Gun;
      if (!Gun.window) {
        require_axe();
      }
      Gun.on("opt", function(at) {
        start(at);
        this.to.next(at);
      });
      function start(root) {
        if (root.axe) {
          return;
        }
        var opt = root.opt, peers = opt.peers;
        if (false === opt.axe) {
          return;
        }
        if (!Gun.window) {
          return;
        }
        var w = Gun.window, lS = w.localStorage || opt.localStorage || {}, loc = w.location || opt.location || {}, nav = w.navigator || opt.navigator || {};
        var axe = root.axe = {}, tmp, id;
        var mesh = opt.mesh = opt.mesh || Gun.Mesh(root);
        tmp = peers[id = loc.origin + "/gun"] = peers[id] || {};
        tmp.id = tmp.url = id;
        tmp.retry = tmp.retry || 0;
        tmp = peers[id = "http://localhost:8765/gun"] = peers[id] || {};
        tmp.id = tmp.url = id;
        tmp.retry = tmp.retry || 0;
        Gun.log.once("AXE", "AXE enabled: Trying to find network via (1) local peer (2) last used peers (3) a URL parameter, and last (4) hard coded peers.");
        Gun.log.once("AXEWarn", "Warning: AXE is in alpha, use only for testing!");
        var last = lS.peers || "";
        if (last) {
          last += " ";
        }
        last += ((loc.search || "").split("peers=")[1] || "").split("&")[0];
        root.on("bye", function(peer) {
          this.to.next(peer);
          if (!peer.url) {
            return;
          }
          if (!nav.onLine) {
            peer.retry = 1;
          }
          if (peer.retry) {
            return;
          }
          if (axe.fall) {
            delete axe.fall[peer.url || peer.id];
          }
          (function next() {
            if (!axe.fall) {
              setTimeout(next, 9);
              return;
            }
            var fall = Object.keys(axe.fall || ""), one = fall[Math.random() * fall.length >> 0];
            if (!fall.length) {
              lS.peers = "";
              one = "https://gunjs.herokuapp.com/gun";
            }
            if (peers[one]) {
              next();
              return;
            }
            mesh.hi(one);
          })();
        });
        root.on("hi", function(peer) {
          this.to.next(peer);
          if (!peer.url) {
            return;
          }
          return;
          (function next() {
            if (!peer.wire) {
              return;
            }
            if (!axe.fall) {
              setTimeout(next, 9);
              return;
            }
            var one = (next.fall = next.fall || Object.keys(axe.fall || "")).pop();
            if (!one) {
              return;
            }
            setTimeout(next, 99);
            mesh.say({ dam: "opt", opt: { peers: one } }, peer);
          })();
        });
        function found(text) {
          axe.fall = {};
          ((text || "").match(/https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)/ig) || []).forEach(function(url) {
            axe.fall[url] = { url, id: url, retry: 0 };
          });
          return;
          Object.keys(last.peers || "").forEach(function(key) {
            tmp = peers[id = key] = peers[id] || {};
            tmp.id = tmp.url = id;
          });
          tmp = peers[id = "https://guntest.herokuapp.com/gun"] = peers[id] || {};
          tmp.id = tmp.url = id;
          var mesh2 = opt.mesh = opt.mesh || Gun.Mesh(root);
          mesh2.way = function(msg) {
            if (root.$ === msg.$ || (msg._ || "").via) {
              mesh2.say(msg, opt.peers);
              return;
            }
            var at = (msg.$ || "")._;
            if (!at) {
              mesh2.say(msg, opt.peers);
              return;
            }
            if (msg.get) {
              if (at.axe) {
                return;
              }
              at.axe = {};
            }
            mesh2.say(msg, opt.peers);
          };
        }
        if (last) {
          found(last);
          return;
        }
        try {
          fetch(((loc.search || "").split("axe=")[1] || "").split("&")[0] || loc.axe || "https://raw.githubusercontent.com/wiki/amark/gun/volunteer.dht.md").then(function(res) {
            return res.text();
          }).then(function(text) {
            found(lS.peers = text);
          }).catch(function() {
            found();
          });
        } catch (e) {
          found();
        }
      }
      var empty = {}, yes = true;
      try {
        if (typeof module != "" + u) {
          module.exports = AXE;
        }
      } catch (e) {
      }
    })();
  }
});
export default require_axe2();
//# sourceMappingURL=gun_axe.js.map
